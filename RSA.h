#include "BigInt.h"

#ifndef RSA_H_
#define RSA_H_

namespace RSAUtil
{

/****************************************************************************************
  Класс, который реализует 32-разрядное шифрование с использованием шифрования с открытым ключом RSA. Этот класс
 * предоставляет методы для генерации открытого и закрытого ключей (поочередно, открытого 
 * ключ может быть установлен явно) и для шифрования и дешифрования RSA.
 * P и Q генерируются случайным образом (с использованием srand() из <cstdlib>), но они могут быть 
 * при желании указывается в конструкторе. (Эта функция используется в основном для тестирования.)
 * Предусмотрены дополнительные вспомогательные функции для поиска gcd, тестирования на простоту и
 * нахождение модульной инверсии числа.
 * 
 * @класс: RSA
 * @пространство имен: RSAUtil
 * @файл: RSA.h
 * **************************************************************************************
 */
class RSA
{
private:
	//17 бит случайно сгенерированных простых чисел. p != q.
	unsigned int p, q;
	// модуль, n=p * q.
	BigInt n;
	// для всех, phi=(p-1)(q-1).
	BigInt phi;	
	// открытый ключ. gcd(e, phi) == 1.
	BigInt e;
	// закрытый ключ. [ed == 1] мод n.
	BigInt d;
	
	// Вычислить открытый и закрытый ключи.
	void calcE();
	void calcD();
	
	
public:

	/************************************************************************************
	* Конструкторы. Генерирует p & q, s.t. p!= q && p и q оба являются простыми.
	* Если в качестве параметра задан один int, он присваивается p и проверка не выполняется.
	* делается на основе его обоснованности (простоты). Если задано два целых числа, первое равно
	* p, второй - q, и проверка на достоверность не проводится. Конструктор
	* инициализирует n и phi.
	 * **********************************************************************************
	 */
	RSA();
	RSA(int);
	RSA(int, int);
	virtual ~RSA();
	
	/*
	 * *********************************************************************************
	 * Методы доступа.
	 * *********************************************************************************
	 */
	BigInt getPublicKey();
	BigInt getPrivateKey();
	BigInt getModulus() const;
	//Returns phi, the totient of the modulus.
	BigInt getPHI() const;
	int getP() const;
	int getQ() const;
	
	/*
	 * *********************************************************************************
	 * Методы-модификаторы.
	 * *********************************************************************************
	 */
	 
	/*
	 * ********************************************************************************
	 * Публичный ключ может быть назначен явно. Проверка валидации отсутствует.
		* выполнено.
	* @parameter unsigned int: целое число, используемое в качестве открытого ключа.
	 * ********************************************************************************
	 */
	void setPublicKey(unsigned int);
	// перегруженная функция для BigInt, созданная Рагхунатаном Шринивасаном  
	 void setPublicKey(BigInt B);
	
	/*
	 * *********************************************************************************
	* Выполняет шифрование/ дешифрование с открытым ключом для данного сообщения. Сообщение должно
	* быть <= 32 бита. Автоматическое преобразование из std::bitset<> или int в BigInt является
	* возможно.
	 * *********************************************************************************
	 */
	BigInt encrypt(BigInt);
	BigInt decrypt(BigInt);

	/* Следующие 4 функции, добавленные Рагхунатаном Шринивасаном */



    void setN(BigInt B);
	// Остальные функции, удаленные для проекта
};


/*
 * **************************************************************************************
 * Вспомогательные функции. Эти функции могут быть доступны как часть пространства имен RSAUtil.
 * Любой доступ к объектам RSA или BigInt осуществляется через их общедоступные методы.
 * **************************************************************************************
 */

/*
 * *******************************************************************************
 * Использует расширенный алгоритм Евклида для нахождения модульного обратного,
 * b такой, что [ab == 1] mod m.
 * @параметр BigInt: это "а" в приведенном выше уравнении.
 * @параметр BigInt: это 'm' в приведенном выше уравнении.
 * @возвращает BigInt: это 'b' в приведенном выше уравнении.
 * *******************************************************************************
 */
BigInt modInverse(BigInt, BigInt);

/*
 * *******************************************************************************
 * Тесты на простоту. Эта функция сначала проверяет делимость на первый
 * 100 простых чисел, а затем, если целое число проходит этот тест, используется формула Миллера-Рабина.
 * алгоритм тестирования на композиционность.
 * @parameter int: целое число, подлежащее проверке на простоту.
 * @возвращает bool: False, если число является составным, True, если число считается верным
 * быть простым с ??% уверенностью.
 * *******************************************************************************
 */
bool isPrime(int);

/*
 * ********************************************************************************
 * Использует алгоритм Миллера-Рабина для проверки возможной простоты. Тесты с пятью
 * различные возможные свидетели для уверенности в ??%. 
 * @parameter int: целое число, подлежащее проверке на простоту.
 * @возвращает bool: False, если число является составным, True, если число считается верным 
 * быть главным.
 * *********************************************************************************
 */
bool isPrimeMR(int);

/*
 * *********************************************************************************
  Проверяет делимость на первые 100 простых чисел.
 * @parameter int: целое число, подлежащее проверке на простоту.
 * @возвращает значение bool: False, если число делится на одно из первых 100 простых чисел,
 * Значение True, если число не делится ни на одно из первых 100 простых чисел.
 * *********************************************************************************/
bool isPrimeDiv(int);

/*
 * *******************************************************************************
 * Рекурсивная функция выполняет алгоритм Евклида для нахождения наибольшего общего
 * делитель двух целых чисел.
 * @параметр int: первое целое число.
 * @параметр int: второе целое число.
 * @возвращает int: наибольший общий делитель первого и второго целых чисел.
 * *******************************************************************************
 */
int gcd(int, int);

/*
 * *********************************************************************************
 * Рекурсивная функция выполняет алгоритм Евклида для нахождения наибольшего общего
 * делитель двух целых чисел.
 * @параметр BigInt: первое целое число.
 * @параметр BigInt: второе целое число.
 * @возвращает BigInt: наибольший общий делитель первого и второго целых чисел.
 * **********************************************************************************
 */
BigInt gcd(BigInt, BigInt);


}

#endif /*RSA_H_*/
